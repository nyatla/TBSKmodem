# TBSK modem

TBSK (Trait Block Shift Keying) modemは、FFT/IFTTを使わない、低速、短距離の音響通信の実装です。

バイト/ビットストリームの振幅信号への変調、振幅信号からバイト/ビットストリームへの復調ができます。


## 性能

静かな室内での音響通信性能は、ビットレートが5bps～1kbps、通信距離は1mくらいです。
パソコンに備わるマイクとスピーカーで通信ができます。

その他の媒体でも、それなりに波形を伝送できれば通信できると思います。


## 仕様

| パラメータ | 値 |
| --- | --- |
| 変調方式 | 特徴ブロック差動変調 |
| ビットレート | 5～1kbps |
| 搬送波周波数 | 任意 |
| 帯域幅 | 5Hz～全帯域 |
| エラー訂正/検出 | なし |

### 特徴ブロック差動変調

TBSKでは、波形シンボルの代わりにスペクトラム拡散した任意形状トーン信号とその反転値を伝送シンボルに使います。
隣接するシンボルの相関値は1,-1を取るので、これを差動変調して伝送します。

### 信号同期

信号の検出と同期は、相関値を一定時間観測して判定します。信号の先端には通常のシンボルよりも長い同期パターンを配置します。

### トーン信号

トーン信号は受信機でS/N比が高い形状であれば何でも構いません。搬送周波数だけ適合していれば、異なるトーン信号で変調しても復調することができます。
トーン信号にサイン波を使用すると、DPSK変調と同じ動作をします。

### 外乱耐性

トーン信号が長いほど外乱耐性は強くなりますが、トーン信号が長くなるほどビットレートは低下します。
搬送波周波数に対する最大通信レートの理論値は1bit/Hzです。実際には0.01bit/Hzが目安となります。


### パケット仕様
現状のプロトコルは、開始点検出とそれに続くペイロード読出しのみを実装しています。パケットサイズや終端識別子、エラー訂正、検出についてはアプリケーションで実装してください。






## ライセンス

本ソフトウェアは、MITライセンスで提供します。ホビー・研究用途では、MITライセンスに従って適切に運用してください。
産業用途では、特許の取り扱いに注意してください。

このライブラリはMITライセンスのオープンソースソフトウェアですが、特許フリーではありません。





## GetStarted

Anacondaの利用を前提として説明します。Pythonのバージョンは、Python 3.10.xを推奨します。

### セットアップ
ソースコードをgithubからcloneします。

```
git clone https://github.com/nyatla/TBSKmodem.git
```

step4までは外部モジュールは不要です。
step4より先に進むならば、numpy,sounddeviceをインストールしてください。
サウンドの再生やキャプチャに必要です。

```
conda install -c anaconda numpy
conda install -c conda-forge python-sounddevice
```

※代替としてpyaudioを利用する場合は、キャプチャのみ対応します。


### サンプルプログラムの場所

サンプルプログラムはTBSKmodem/getstartedディレクトリにあります。

#### step1. データをwaveファイルに変換する。
step1.modulate.pyは、ビット値を変調することができます。

```
> python step1_modulate.py
```

このスクリプトは変調した振幅信号をwavファイルに保存します。
ファイル名は、step1.wavです。

modulateAsBit関数は、ビット値(1 or 0)の配列を変調した振幅値を返すイテレータを生成します。


#### step2. wavファイルの復調

step2.modulate.pyは、作成したwavファイルを元のビット列に戻します。
```
> python step2_demodulate.py
```

当然のように、元のビット列に戻るはずです。

demodulateAsBit関数は1ビットの値を受信した順に返すイテレータを生成します。
信号が成立しなくなるまで値をビット値を返し続けます。(信号終端についての疑問はここでは一旦忘れます。)


#### step3. バイトデータの変調と復調

バイト値を送受信する関数も当然実装済みです。
step3_bytedata.pyは、bytes値の変調と復調を実行します。

```
> python step3_bytedata.py
```

入力は連続するbytes値なのに、戻り値は1bytesづつに分割されたbytes型で得られる点に注意してください

#### step4. バイトデータの変調と復調

step4_text.pyは、文字列の変調と復調を実行します。

```
> python step4_text.py
```
step4_text.pyとstep3_bytedata.pyは、同じmodulete関数で変調していることに注目してください。
modulete関数には、3種類(Iterableも入れるなら4種類)のオーバライド関数があります。

byte範囲のint値配列,bytes,strを引数にそのまま指定できるので便利です。

#### step5. マイク入力のテスト

step5_microphone.pyで、サウンドデバイスがpythonからアクセスできるかテストしましょう。

```
> python step5_microphone.py
```

マイクに向かって、一曲歌いましょう。選曲はお任せします。
"#"で示されるバーグラフが動いていれば、pythonは正常にマイクを認識しています。

うまく認識できない場合は次の事を試してください。

1. マイクがPCに接続されているか確認する。
2. スクリプトのdevice_idパラメータを変更する(1,2,3...)
3. 他のプログラムでマイクを認識しているか確認する。
4. もっと大きな声で歌う。

#### step6. リアルタイム送受信

仕上げに、step6_realtime_receive.pyでリアルタイムに信号を復調します。
マイクの準備は宜しいですか？

```
> python step6_realtime_receive.py
```

実行したディレクトリに、step6.wavが生成されています。
このWaveファイルをpythonに聞かせてください。
復調した文字列が表示されます。

スマートフォンを持っているなら、こちらのmp3を再生してください。


ところで、受信した信号の終端はどこなのか？という疑問が残されたままです。
TBSKでは、信号を検知した後、信号強度が閾値を超えていれば、それが何であっても延々と値を復調し続けます。
上位の通信仕様でパケット長を固定したり、長さパラメータを初めに送信するなどして対処してください。


### そのほかの遊び方

いろいろな周波数や波形で信号を作りましょう。
TBSKのトーン信号は、ある程度の特徴があればどんな波形でも使えます。環境や目的に合わせてチューニングを楽しめます。



## 👈To Be Continued ▲▼▲

さて、来週(来年)の目標は、

1. Unity向けのC#実装
2. マイコン/WASM向けのC++実装
3. OFDM ? DSSS…?

の３本です。

